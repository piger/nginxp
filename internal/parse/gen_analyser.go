//go:build ignore

package main

import (
	"bufio"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
)

var (
	pyAnalyzerURL = "https://raw.githubusercontent.com/nginxinc/crossplane/master/crossplane/analyzer.py"

	directivesStart = regexp.MustCompile(`^DIRECTIVES = \{$`)
	bitMaskDef      = regexp.MustCompile(`^NGX_`)
	bitMaskDefAny   = regexp.MustCompile(`^NGX_ANY_CONF = \($`)
	endPipe         = regexp.MustCompile(`\| *$`)
	directiveDef    = regexp.MustCompile(`'([^']+)': \[`)
	comment         = regexp.MustCompile(`^ *#`)
	blank           = regexp.MustCompile(`^ *$`)
)

func generateAnalyser() error {
	resp, err := http.Get(pyAnalyzerURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// contexts:
	// 0: root context
	// 1: NGX_ANY_CONF section
	// 2: directives
	// 3: other

	context := 0

	fh, err := os.OpenFile("bitmasks.go", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer func() {
		if err := fh.Close(); err != nil {
			log.Print(err)
		}
	}()

	fmt.Fprintf(fh, "package parse\n\n// THIS FILE IS AUTOGENERATED\n\nvar (\n")

	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := scanner.Text()

		if directivesStart.MatchString(line) {
			context = 2
			fmt.Fprintf(fh, ")\n\n")
			fmt.Fprintf(fh, "var dirMask = map[string][]int{\n")
			continue
		}

		if context == 0 {
			// start of: NGX_ANY_CONF = (
			if bitMaskDefAny.MatchString(line) {
				context = 1
				fmt.Fprintln(fh, line)
			} else if bitMaskDef.MatchString(line) {
				// common bitmask declaration
				// example: NGX_CONF_NOARGS = 0x00000001  # 0 args
				line = strings.ReplaceAll(line, "#", "//")
				fmt.Fprintln(fh, line)
			}
		} else if context == 1 {
			if !endPipe.MatchString(line) {
				line = line + ")"
				context = 0
				fmt.Fprintln(fh, line)
			} else if line != ")" {
				fmt.Fprintln(fh, line)
			} else if line == ")" {
				context = 0
			}
		} else if context == 2 {
			if comment.MatchString(line) {
				continue
			}

			m := directiveDef.FindStringSubmatch(line)
			if m != nil && len(m) > 1 {
				fmt.Fprintf(fh, `"%s": {`, m[1])
			} else if strings.HasSuffix(line, "],") || strings.HasSuffix(line, "]") {
				fmt.Fprintf(fh, "},\n")
			} else if strings.HasSuffix(line, ",") {
				fmt.Fprintf(fh, "%s", line)
			} else if line == "}" {
				context = 3
				fmt.Fprintf(fh, "}\n")
			} else if blank.MatchString(line) {
				// no-op
			} else {
				fmt.Fprint(fh, line)
			}
		}
	}
	if err := scanner.Err(); err != nil {
		return err
	}

	return nil
}

func main() {
	if err := generateAnalyser(); err != nil {
		log.Print(err)
	}
}
